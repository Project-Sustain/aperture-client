<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdn.rawgit.com/socib/Leaflet.TimeDimension/master/dist/leaflet.timedimension.control.min.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css"
        integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
        crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"
        integrity="sha512-nMMmRyTVoLYqjP9hrbed9S+FzjZHW5gY1TWCHA5ckwXZBadntCNs8kEqAWdrb9O7rxbCaA4lKTIWjDXZxflOcA=="
        crossorigin=""></script>
    <script type="text/javascript" src="https://cdn.rawgit.com/nezasa/iso8601-js-period/master/iso8601.min.js"></script>
    <script type="text/javascript" src="https://cdn.rawgit.com/socib/Leaflet.TimeDimension/master/dist/leaflet.timedimension.min.js"></script>
    <script src="Dependencies/leaflet-voronoi.js"></script>
    <link rel="stylesheet" type="text/css" href="IframeStyle.css">
</head>
<body>
    <script src="Dependencies/mouseDown.js"></script>
    <script src="Dependencies/time-dimension.js"></script>
    <div id='map1' class='map'></div>
    
    <script>
        var Geohash = {};
        var points = [];
        var pointLocations = {};
        var bounds = {};
        var mins = {};
        var maxes = {};
        var featureDict = {};
        var delaunay = null;
        var mymap = null;
        var polygonLayer = null;
        var polygonLayerGroup = null;
        var view = {lat: 40.7580, lng: 286.0145};
        var zoomLevel = 3;
        var data = [];
        Geohash.base32 = '0123456789bcdefghjkmnpqrstuvwxyz';

        function decode_geohash(geohash) {

            var bounds = geohash_bounds(geohash); // <-- the hard work
            // now just determine the centre of the cell...

            var latMin = bounds.sw.lat, lonMin = bounds.sw.lon;
            var latMax = bounds.ne.lat, lonMax = bounds.ne.lon;

            // cell centre
            var lat = (latMin + latMax)/2;
            var lon = (lonMin + lonMax)/2;

            // round to close to centre without excessive precision: ⌊2-log10(Δ°)⌋ decimal places
            lat = lat.toFixed(Math.floor(2-Math.log(latMax-latMin)/Math.LN10));
            lon = lon.toFixed(Math.floor(2-Math.log(lonMax-lonMin)/Math.LN10));

            return { lat: Number(lat), lon: Number(lon) };
        };

        function encode_geohash(lat, lon, precision) {
            // infer precision?
            if (typeof precision == 'undefined') {
                // refine geohash until it matches precision of supplied lat/lon
                for (var p=1; p<=12; p++) {
                    var hash = encode_geohash(lat, lon, p);
                    var posn = decode_geohash(hash);
                    if (posn.lat==lat && posn.lon==lon) return hash;
                }
                precision = 12; // set to maximum
            }

            lat = Number(lat);
            lon = Number(lon);
            precision = Number(precision);

            if (isNaN(lat) || isNaN(lon) || isNaN(precision)) throw new Error('Invalid geohash');

            var idx = 0; // index into base32 map
            var bit = 0; // each char holds 5 bits
            var evenBit = true;
            var geohash = '';

            var latMin =  -90, latMax =  90;
            var lonMin = -180, lonMax = 180;

            while (geohash.length < precision) {
                if (evenBit) {
                    // bisect E-W longitude
                    var lonMid = (lonMin + lonMax) / 2;
                    if (lon >= lonMid) {
                        idx = idx*2 + 1;
                        lonMin = lonMid;
                    } else {
                        idx = idx*2;
                        lonMax = lonMid;
                    }
                } else {
                    // bisect N-S latitude
                    var latMid = (latMin + latMax) / 2;
                    if (lat >= latMid) {
                        idx = idx*2 + 1;
                        latMin = latMid;
                    } else {
                        idx = idx*2;
                        latMax = latMid;
                    }
                }
                evenBit = !evenBit;

                if (++bit == 5) {
                    // 5 bits gives us a character: append it and start over
                    geohash += Geohash.base32.charAt(idx);
                    bit = 0;
                    idx = 0;
                }
            }

            return geohash;
        };

        function geohash_bounds(geohash) {
            if (geohash.length === 0) throw new Error('Invalid geohash');

            geohash = geohash.toLowerCase();

            var evenBit = true;
            var latMin =  -90, latMax =  90;
            var lonMin = -180, lonMax = 180;

            for (var i=0; i<geohash.length; i++) {
                var chr = geohash.charAt(i);
                var idx = Geohash.base32.indexOf(chr);
                if (idx == -1) throw new Error('Invalid geohash');

                for (var n=4; n>=0; n--) {
                    var bitN = idx >> n & 1;
                    if (evenBit) {
                        // longitude
                        var lonMid = (lonMin+lonMax) / 2;
                        if (bitN == 1) {
                            lonMin = lonMid;
                        } else {
                            lonMax = lonMid;
                        }
                    } else {
                        // latitude
                        var latMid = (latMin+latMax) / 2;
                        if (bitN == 1) {
                            latMin = latMid;
                        } else {
                            latMax = latMid;
                        }
                    }
                    evenBit = !evenBit;
                }
            }

            var bounds = {
                sw: { lat: latMin, lon: lonMin },
                ne: { lat: latMax, lon: lonMax },
            };

            return bounds;
        };

        function geohash_adjacent(geohash, direction) {
            // based on github.com/davetroy/geohash-js

            geohash = geohash.toLowerCase();
            direction = direction.toLowerCase();

            if (geohash.length === 0) throw new Error('Invalid geohash');
            if ('nsew'.indexOf(direction) == -1) throw new Error('Invalid direction');

            var neighbour = {
                n: [ 'p0r21436x8zb9dcf5h7kjnmqesgutwvy', 'bc01fg45238967deuvhjyznpkmstqrwx' ],
                s: [ '14365h7k9dcfesgujnmqp0r2twvyx8zb', '238967debc01fg45kmstqrwxuvhjyznp' ],
                e: [ 'bc01fg45238967deuvhjyznpkmstqrwx', 'p0r21436x8zb9dcf5h7kjnmqesgutwvy' ],
                w: [ '238967debc01fg45kmstqrwxuvhjyznp', '14365h7k9dcfesgujnmqp0r2twvyx8zb' ],
            };
            var border = {
                n: [ 'prxz',     'bcfguvyz' ],
                s: [ '028b',     '0145hjnp' ],
                e: [ 'bcfguvyz', 'prxz'     ],
                w: [ '0145hjnp', '028b'     ],
            };

            var lastCh = geohash.slice(-1);    // last character of hash
            var parent = geohash.slice(0, -1); // hash without last character

            var type = geohash.length % 2;

            // check for edge-cases which don't share common prefix
            if (border[direction][type].indexOf(lastCh) != -1 && parent !== '') {
                parent = geohash_adjacent(parent, direction);
            }

            // append letter for direction to parent
            return parent + Geohash.base32.charAt(neighbour[direction][type].indexOf(lastCh));
        };


        mymap = L.map('map1', {renderer: L.canvas(), minZoom: 3, 
            fullscreenControl: true,
            timeDimension: true, //timeDimensionControl: true,
			timeDimensionOptions: {
        		    timeInterval: window.parent.document.getElementById("starttime").value + "/" + window.parent.document.getElementById("endtime").value,
        		    transitionTime: 0.1,
        		    period: "PT6H",
                    currentTime: new Date(window.parent.document.getElementById("starttime").value)},
                       }
        ).setView(window.parent.view, window.parent.zoomLevel);

        L.timeDimension.layer.VoronoiLayer = function(points, options) {
            return new L.TimeDimension.Layer.VoronoiLayer(points, options);
        };

        var tiles = L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
                attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
                maxZoom: 18,
                id: 'mapbox.streets',
                accessToken: 'pk.eyJ1Ijoia2V2aW5icnVod2lsZXIiLCJhIjoiY2ptdjBuMzRiMGNzeTNwbm9sYml5aWhvcyJ9.i6hZMqiVZgDiyDj5zcFcIA',
            maxBounds: [[],[]]
        }).addTo(mymap);

        polygonLayer = L.timeDimension.layer.VoronoiLayer({loadingTimeout: 1000000});
        polygonLayer.addTo(mymap);


        L.Control.TimeDimensionCustom = L.Control.TimeDimension.extend({
            _getDisplayDateFormat: function(date){
                return date;
            }
        });

        var timeDimensionControl = new L.Control.TimeDimensionCustom({
            autoPlay: false,
            maxSpeed: 10,
            playerOptions: {
                buffer: 1,
                minBufferReady: -1,
                transitionTime: 100,	
            },
        });
        mymap.addControl(this.timeDimensionControl);
        polygonLayer.addControlReference(timeDimensionControl);

        mymap.on("move", function () {
            parent.setGlobalPosition(mymap.getCenter(),1);
            parent.setGlobalZoom(mymap.getZoom(),1);
        });
    </script>

    <!--You must add this map's setter function-->
    <script> 
        var thisMapsSetter = function(view,zoom){
            mymap.setView(view, mymap.getZoom());
        }
        parent.setterFunctions.push(thisMapsSetter);
    </script> 
</body>